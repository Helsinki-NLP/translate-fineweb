| original | translation |
|----------|-------------|
| The Brief History of Basketball<br/><br/>11 May 2020<br/><br/>James Naismith was the first person to come up with basketball in 1891. He was a student at Springfield, Massachusetts, and he was urged by his teacher to come up with an indoor game that had fewer injuries. Hence, he came up with a ball game that involved 18 players who had to shoot a ball into a peach basket.<br/><br/>Within the first decade of the invention, the game proliferated in the United States, and colleges united to form leagues. In 1898, Naismith became the basketball coach of the University of Kansas, where he recorded the only loss in Kansas to date.<br/><br/>The US Army and the YMCA played a massive part in introducing basketball to the world. The first international game was organized in 1893 and was played in Japan, India, China, and Persia. Two years later, Hamline University and the University of Minnesota played the first recorded basketball game. The game saw the latter with a margin of six baskets. In 1896, the University of Chicago and Lowa played a five aside game that saw Chicago beat Lowa 15-12. The first professional league that incorporated six teams was formed in 1898. However, due to mismanagement, it was disbanded later in 1904, and only collegiate teams were left. Basketball teams played friendly games betting against themselves, including the original Celtics, which was the most exceptional team at that time.<br/><br/>In 1904, teams petitioned for international organizations to recognize basketball as an Olympic sport. The complaint lasted for years till June 18, 1932, when FIBA was established. However, that was not yet the end of the struggle, FIBA was entitled to make basketball an Olympic game, but they failed in every attempt. However, in 1936 they were able to succeed in their quest, and the first international basketball Olympic sport was played, with the US team winning the tournament.<br/><br/>Initially, the game had different rules compared to the current game. In the 19th century, the game was played using soccer balls, and no metal rings, backboards, or nets were included. Furthermore, players were not allowed to track or dribble with the ball. Instead, they used to pass the ball without changing their movement. However, with time the rules were amended to suit the current basketball game.<br/><br/>In June 1946, the Basketball Association Of America was established in New York City. Three years down the line, the association name was changed to National Basketball Association after the alliance with rival National Basketball League. However, to date, the NBA (check out victoriahighlandersfc.com NBA 뉴스) for some interesting stats) is one of the most popular basketball leagues on the planet. Since its establishment in 1949, the association has produced prominent, talented people such as Michael Jordan, Kobe Bryant, Shaquille O'Neal, LeBron James, among | Scurta istorie a baschetului<br/><br/>11 mai 2020<br/><br/>James Naismith a fost prima persoană care a venit cu baschet în 1891. El a fost un student la Springfield, Massachusetts, și a fost îndemnat de profesorul său să vină cu un joc de interior care a avut mai puține răniri. Prin urmare, el a venit cu un joc de minge care a implicat 18 jucători care au trebuit să tragă o minge într-un coș de piersici.<br/><br/>În primul deceniu al invenției, jocul a proliferat în Statele Unite, iar colegiile s-au unit pentru a forma ligi. În 1898, Naismith a devenit antrenorul de baschet al Universității din Kansas, unde a înregistrat singura pierdere din Kansas până în prezent.<br/><br/>Armata SUA și YMCA au jucat un rol masiv în introducerea baschetului în lume. Primul joc internațional a fost organizat în 1893 și a fost jucat în Japonia, India, China și Persia. Doi ani mai târziu, Universitatea Hamline și Universitatea din Minnesota au jucat primul meci de baschet înregistrat. Jocul l-a văzut pe acesta din urmă cu o marjă de șase coșuri. În 1896, Universitatea din Chicago și Lowa au jucat un meci de cinci laturi care a văzut Chicago învingând Lowa 15-12. Prima ligă profesionistă care a încorporat șase echipe a fost formată în 1898. Cu toate acestea, din cauza gestionării defectuoase, a fost dizolvat mai târziu în 1904, și au rămas doar echipe colegiale. Echipele de baschet au jucat meciuri amicale împotriva lor, inclusiv Celtics originale, care a fost echipa cea mai excepțională la acel moment.<br/><br/>În 1904, echipele au solicitat organizațiilor internaționale să recunoască baschetul ca sport olimpic. Plângerea a durat ani de zile până la 18 iunie 1932, când a fost înființată FIBA. Cu toate acestea, că nu a fost încă sfârșitul luptei, FIBA a avut dreptul de a face baschetul un joc olimpic, dar au eșuat în fiecare încercare. Cu toate acestea, în 1936 au reușit să reușească în căutarea lor, iar primul sport olimpic internațional de baschet a fost jucat, echipa americană câștigând turneul.<br/><br/>Inițial, jocul a avut reguli diferite în comparație cu jocul actual. În secolul al XIX-lea, jocul a fost jucat folosind mingi de fotbal și nu au fost incluse inele metalice, panouri sau plase. În plus, jucătorii nu aveau voie să urmărească sau să dribleze cu mingea. În schimb, ei obișnuiau să treacă mingea fără a-și schimba mișcarea. Cu toate acestea, cu timpul, regulile au fost modificate pentru a se potrivi jocului actual de baschet.<br/><br/>În iunie 1946, Asociația de Baschet din America a fost înființată în New York City. Trei ani mai târziu, numele asociației a fost schimbat în Asociația Națională de Baschet după alianța cu Liga Națională de Baschet rivală. Cu toate acestea, până în prezent, NBA (vezi victoriahighlandersfc.com NBA 뉴스) pentru unele statistici interesante) este una dintre cele mai populare ligi de baschet de pe planetă. De la înființarea sa în 1949, asociația a produs oameni proeminenți și talentați, cum ar fi Michael Jordan, Kobe Bryant, Shaquille O'Neal, LeBron James, printre alții. |
| tag:blogger.com,1999:blog-6401154681092369840.post8133159609228442019..comments2018-09-04T02:59:25.470-04:00Comments on  Salcedo Cargo Express apoyando el deporteTtegatagas@gmail.com like you learn my mind! You appear to understa...<br />Its like you learn my mind! You appear to understand a lot approximately this, such as you wrote the ebook in it or something. I feel that you can do with some p.c. to drive the message home a bit, but instead of that, this is great blog. A great read. I will definitely be back. <a href=" rel="nofollow">gmail.com login</a>Anonymous | tag:blogger.com,1999:blog-6401154681092369840.post8133159609228442019..comments2018-09-04T02:59:25.470-04:00Comentariile la Salcedo Cargo Express susțin sportTtegatagas@gmail.com ca și cum ai învăța mintea mea! Se pare că subsistați...<br />E ca și cum ați învăța mintea mea! Se pare că înțelegeți mult aproximativ acest lucru, cum ar fi că ați scris cartea electronică în ea sau ceva. Simt că puteți face cu unele pc. pentru a conduce mesajul acasă un pic, dar în loc de asta, acesta este un blog mare. O lectură mare. Voi fi cu siguranță înapoi. <a href=" rel="nofollow">autentificare gmail.com</a>Anonim |
| TRENDING:<br/><br/>SPONSORED:<br/><br/>Florida 9-year-old gives his teacher 'pay raise' with birthday money<br/><br/>A third-grade student in Florida used his birthday money to gift a "pay raise" to his teacher, saying that the decision came easy because she has "the most important job."<br/><br/>Parker Williams told NBC affiliate WFLA that he wanted to give the $15 he received on his ninth birthday to someone who deserved to make more money. He told the news station that his Gorrie Elementary School teacher fit that description, describing her as someone who is "nice and kind" and always spends time on every student.<br/><br/>ADVERTISEMENT<br/><br/>"I don't think they get paid very much. And, so I think that I wanted to give my teacher a gift and share my ideas," he said.<br/><br/>Parker attached the $15 to a note that read: "Dear Mrs. Chambers, I don't think that teachers get paid enough for what they do, so will you accept this gift?"<br/><br/>Mrs. Chambers later returned the "pay raise" to Parker, saying in a note to the student, "I can't accept this, but appreciate the gesture, Parker. Students like you are the reason I teach."<br/><br/>Parker's father and mother found about their son's deed after discovering the notes from him and his teacher in his backpack. Parker's mother told the news station that her eyes immediately began "welling up with tears" knowing that her son took the initiative on his own.<br/><br/>Parker's father later shared the episode on Facebook, in a post that quickly went viral. | TENDENŢĂ:<br/><br/>Sponsorizat:<br/><br/>Un copil de 9 ani din Florida i-a dat profesorului său bani pentru ziua de naștere<br/><br/>Un elev din clasa a treia din Florida și-a folosit banii pentru ziua de naștere pentru a-i oferi profesorului său o "creștere de salariu", spunând că decizia a fost ușoară pentru că ea are "cel mai important loc de muncă".<br/><br/>Parker Williams a declarat pentru WFLA că vrea să dea cei 15 dolari pe care i-a primit la a noua aniversare unei persoane care merită să facă mai mulți bani. El a declarat pentru postul de știri că profesorul său de la Gorrie Elementary School se potrivește acestei descrieri, descriind-o ca pe cineva care este "frumoasă și bună" și petrece întotdeauna timp cu fiecare elev.<br/><br/>PUBLICITATE<br/><br/>"Nu cred că sunt plătiți foarte mult. Și, așa că cred că am vrut să-i dau profesorului meu un cadou și să-mi împărtășesc ideile", a spus el.<br/><br/>Parker a atașat cei 15 dolari pe o notă care spunea: „Dragă doamnă Chambers, nu cred că profesorii sunt plătiți suficient pentru ceea ce fac, așa că veți accepta acest cadou?”<br/><br/>Mai târziu, doamna Chambers i-a returnat lui Parker mărirea de salariu, spunând într-o notă studentului: „Nu pot accepta acest lucru, dar apreciez gestul, Parker. Studenții ca tine sunt motivul pentru care predau.”<br/><br/>Tatăl și mama lui Parker au aflat despre fapta fiului lor după ce au descoperit notițele lui și ale profesorului său în rucsac. Mama lui Parker a declarat pentru postul de știri că ochii ei au început imediat să „se umfle de lacrimi”, știind că fiul ei a luat inițiativa pe cont propriu.<br/><br/>Tatăl lui Parker a postat mai târziu episodul pe Facebook, într-o postare care a devenit rapid virală. |
| The figures of coronavirus cases in the U.S. still remain high. Coronavirus keeps all people on alert in Forman and today, the virus still spreads across Sargent County. Its population density is informed to be 4 people per mi2 (1 people per km2) so the risk of being infected is below average. As for the state, the North Dakota officials mentioned about 77K cases of COVID-19, an increase of 790 | Cifrele cazurilor de coronavirus în SUA rămân încă ridicate. Coronavirusul ține toți oamenii în alertă în Forman și astăzi, virusul se răspândește încă în întregul județ Sargent. Densitatea populației sale este informată să fie de 4 persoane pe mi2 (1 persoane pe km2), astfel încât riscul de a fi infectat este sub medie. În ceea ce privește statul, oficialii din Dakota de Nord au menționat aproximativ 77K cazuri de COVID-19, o creștere de 790 |
| 大家好,我最近在用FDTD仿真一种混合线栅结构,结构非常简单,就是石墨烯带和PEC带相互交替的混合线栅,希望的结果是PEC光栅与石墨烯线栅之间存在耦合,能够产生Fano共振现象,在分别仿真金属线栅和石墨烯线栅的时候都能够得到与文章一致的结果,但是将两种结构混合起来的时候就无法仿真,会出现下面的错误提示:<br/>The program terminated due to an error:There is a combination of PEC and/or nonlinear media with surface conductivity (graphene) in a single cell, the simulation cannot proceed。<br/>Error: there was an unknown parallel error. The error code is 0<br/>说有网格中同时存在PEC和石墨烯两种材料,不过我仔细看过网格,已经足够细了,并没有一个网格中同时具有这两种材料啊。现在仿真也没法进行了,试过局部加密,仍然会出现同样的错误提示。像大家请教一下,这是什么问题。 | 大子子子子子子子子子子子子子子子子子子子子子子子子子子子子子子子字�<br/>Programul sa încheiat din cauza unei erori: Există o combinație de PEC și / sau medii nonlineare cu conductivitate de suprafață (grafen) într-o singură celulă, simularea nu poate continua.<br/>Eroare: a existat o eroare paralelă necunoscută. Codul de eroare este 0<br/>说期的的的的的的的的的的的的的的的的的的的的的的的的的的的的的的 |
| Ron Paul: 'Leave Ukraine Alone'<br/><br/>Last week Ukraine saw its worst violence since the break-up of the Soviet Union over 20 years ago. Protesters occupying the main square in the capitol city, Kiev, clashed with police leaving many protesters and police dead and many more wounded. It is an ongoing tragedy and it looks like there is no end in sight.<br/><br/>The current conflict stems from a divide between western Ukraine, which seeks a closer association with the European Union, and the eastern part of the country, which has closer historic ties to Russia.<br/><br/>The usual interventionists in the US have long meddled in the internal affairs of Ukraine. In 2004 it was US government money that helped finance the Orange Revolution, as US-funded NGOs favoring one political group over the other were able to change the regime. These same people have not given up on Ukraine. They keep pushing their own agenda for Ukraine behind the scenes, even as they ridicule anyone who claims US involvement.<br/><br/>A recent leaked telephone conversation between two senior government officials made it clear that not only was the US involved in the Ukrainian unrest, the US was actually seeking to determine who should make up the next Ukrainian government!<br/><br/>Senator John McCain, who has made several trips to Ukraine recently to meet with the opposition, wrote last week that the US must stand up to support the territorial integrity of Ukraine, including Crimea.<br/><br/>Why are US government officials so eager to tell the Ukrainians what they should do? Has anyone bothered to ask the Ukrainians? What if might help alleviate the ongoing violence and bloodshed, if the Ukrainians decided to re-make the country as a looser confederation of regions rather than one tightly controlled by a central government? Perhaps Ukraine engaged in peaceful trade with countries both to the west and east would benefit all sides. But outside powers seem to be fighting a proxy war, with Ukraine suffering the most because of it.<br/><br/>If you asked most Americans how they feel, my bet is that you would discover they are sick and tired of the US government getting involved in every crisis that arises. Certainly the American people want none of of this intervention in Ukraine. They understand, as recent polls have shown, that our interventionist foreign policy is only creating more enemies overseas. And they also understand that we are out of money. We could not afford to be the policemen of world even if we wanted to be.<br/><br/>And I bet if we asked the Ukrainians, a vast majority of them would prefer that the US — and Russia and the European Union — stay out their affairs and respect their sovereignty. Is it so difficult to understand why people resent being lectured and bribed by foreign governments? All we need to do is put ourselves in the place of the Ukrainians and ask ourselves how we would feel if we were in the middle of a tug-of-war between a very strong Canada on one side and a very strong Mexico on the other. We would resent it as well. So let's keep our hands off of Ukraine and let them solve their own problems | Ron Paul: "Lăsaţi Ucraina singură"<br/><br/>Săptămâna trecută, Ucraina a văzut cea mai gravă violență de la destrămarea Uniunii Sovietice în urmă cu peste 20 de ani. Protestatarii care ocupă piața principală din capitala Kievului s-au ciocnit cu poliția, lăsând mulți protestatari morți și polițiști și mulți răniți. Este o tragedie în curs de desfășurare și se pare că nu există un sfârșit la vedere.<br/><br/>Conflictul actual provine dintr-o diviziune între vestul Ucrainei, care caută o asociere mai strânsă cu Uniunea Europeană, și partea de est a țării, care are legături istorice mai strânse cu Rusia.<br/><br/>Intervenţioniştii obişnuiţi din SUA s-au amestecat de mult în afacerile interne ale Ucrainei. În 2004, banii guvernului american au fost cei care au ajutat la finanțarea Revoluției Portocalii, deoarece ONG-urile finanțate de SUA care favorizează un grup politic în detrimentul celuilalt au reușit să schimbe regimul. Aceiași oameni nu au renunțat la Ucraina. Ei continuă să-și împingă propria agendă pentru Ucraina în spatele scenei, chiar dacă ridiculizează pe oricine pretinde implicarea SUA.<br/><br/>O conversație telefonică recentă între doi oficiali guvernamentali de rang înalt a clarificat faptul că nu numai că SUA au fost implicate în tulburările ucrainene, ci SUA au căutat de fapt să determine cine ar trebui să alcătuiască următorul guvern ucrainean!<br/><br/>Senatorul John McCain, care a făcut recent mai multe călătorii în Ucraina pentru a se întâlni cu opoziţia, a scris săptămâna trecută că SUA trebuie să se ridice pentru a susţine integritatea teritorială a Ucrainei, inclusiv Crimeea.<br/><br/>De ce sunt oficialii guvernamentali americani atât de dornici să le spună ucrainenilor ce ar trebui să facă? A deranjat cineva să întrebe ucrainenii? Ce s-ar întâmpla dacă ar ajuta la atenuarea violenței și vărsării de sânge în curs, dacă ucrainenii ar decide să reconstruiască țara ca o confederație mai flexibilă de regiuni, mai degrabă decât una strict controlată de un guvern central? Poate că Ucraina angajată în comerțul pașnic cu țările din vest și est ar beneficia toate părțile. Dar puterile externe par să lupte un război prin reprezentare, Ucraina suferind cel mai mult din cauza acestuia.<br/><br/>Dacă i-aţi întreba pe majoritatea americanilor cum se simt, pariul meu este că veţi descoperi că sunt bolnavi şi obosiţi de implicarea guvernului SUA în fiecare criză care apare. Cu siguranţă poporul american nu vrea nimic din această intervenţie în Ucraina. Ei înțeleg, după cum au arătat sondajele recente, că politica noastră externă intervenționistă nu face decât să creeze mai mulți dușmani în străinătate. Și, de asemenea, înțeleg că nu avem bani. Nu ne-am putea permite să fim polițiștii lumii chiar dacă am vrea să fim.<br/><br/>Și pun pariu că dacă i-am întreba pe ucraineni, marea majoritate dintre ei ar prefera ca SUA – și Rusia și Uniunea Europeană – să rămână în afara afacerilor lor și să le respecte suveranitatea. Este atât de greu de înțeles de ce oamenii sunt supărați să fie prelegeri și mituiți de guverne străine? Tot ce trebuie să facem este să ne punem în locul ucrainenilor și să ne întrebăm cum ne-am simți dacă am fi în mijlocul unui război între un Canada foarte puternic pe de o parte și un Mexic foarte puternic pe de altă parte. Aşa că haideţi să ţinem mâinile departe de Ucraina şi să-i lăsăm să-şi rezolve propriile probleme. |
| A paper published this year in Australia by C. Spits, L. Wallace, and K. Reinke; Investigating surface and near-surface bushfire fuel attributes: provides a comparison between visual assessments and Image-Based Point Clouds, and explores the differences in accuracy between using a visual assessment by an individual in the field using a standard called the Overall Fuel Hazard and Assessment Guide and using a three-dimensional technique such as Image-Based Point Clouds to measure a description of the fuel structure or loading. The results of this research indicated that using the three-dimensional techniques were 2 to 8 times more accurate. This new method of collecting data about fuel loading in forests according to the paper showed promising use in helping to define fire management practices in an area where repeatable, accurate results are important to forest management. | O lucrare publicată în acest an în Australia de către C. Spits, L. Wallace și K. Reinke; Investigarea atributelor combustibilului de suprafață și de aproape de suprafață: oferă o comparație între evaluările vizuale și norii de puncte bazați pe imagine și explorează diferențele de precizie între utilizarea unei evaluări vizuale de către un individ în domeniu folosind un standard numit structura de măsurare a riscului de combustibil și Ghidul de evaluare a combustibilului și folosind o tehnică tridimensională. Rezultatele acestei cercetări au indicat că utilizarea tehnicilor tridimensionale a fost de 2 până la 8 ori mai precisă. Această nouă metodă de colectare a datelor despre încărcarea combustibilului în păduri, conform lucrării, a arătat o utilizare promițătoare pentru a ajuta la definirea practicilor de gestionare a incendiilor într-o zonă în care rezultatele repetate și precise sunt importante pentru gestionarea pădurilor. |
| Database Administrators Stack Exchange is a question and answer site for database professionals who wish to improve their database skills and learn from others in the community. It only takes a minute to sign up.<br/><br/>When applications hardcode a schema name, "dbo.TABLE", it reduces the DBA's ability to migrate the data as needed.... uh, false. You can always place views on top of your tables with different schema names, so I think your question is based on a fallacy, which kind of invalidates the question in general. I don't think the question warrants a down-vote, but your thoughts on it being closed is likely accurate.<br/>– John EisbrenerJun 24 '19 at 14:35<br/><br/>@JohnEisbrener - I am open to reasons to use schema names. If the DBA can always replace tables with views resolving to other schemas, then why have applications specify dbo.TABLE rather than just TABLE. If the dba creates a view, TABLE would resolve to dbo.TABLE which is a view to mrpv3.TABLE. What is the value of having source code specify dbo.?<br/>– litJun 24 '19 at 14:43<br/><br/>@ScottHodgin - Yes, I read that before posting. And I agree, that in a poorly managed environment, multiple schemas can cause problems, But, specifying them puts more limits on how a DBA can manage the database. It removes the option of changing the account default schema and requires the use of views. Are there other mechanisms to manage this?<br/>– litJun 24 '19 at 14:54<br/><br/>If you understand that its not a good practice, an alternative will be to use SYNONYM<br/>– Kin ShahJun 24 '19 at 17:30<br/><br/>@MaxVernon - I read the post. It does clearly explain how SQL Server works. My opinion is still that hardcoding a schema name into source makes the code less flexible. Without a schema name, the application can run without any changes by the DBA setting the default schema for the execution user. And, it is one less thing where error can be introduced.<br/>– litJun 24 '19 at 19:50<br/><br/>2 Answers<br/>2<br/><br/>You appear to understand this, but just in case... you do not always have to specify the schema, as long as the schema is the user's default schema.<br/><br/>So you can handle this at the login level of SQL Server. A login can be set to default to, say, the schema 'MySchema'. For this login, the table mySchema.Orders would be the default for that user, addressable as simply Orders.<br/><br/>This isn't used often, since it can get confusing, but it is a fully functional way of doing this. But note: if you don't have the table mySchema.Orders in your database, the system WILL look for dbo.Orders as well. This is great if you want some tables personalized and some in common - bad if the mySchema users should not have access to dbo tables.<br/><br/>Short answer here is No, it is neither "safe", nor "expedient", and arguably not more flexible to omit the schema name. In fact, doing so is one of the classic ways of "shooting yourself in the foot."<br/><br/>One of the primary rules of programming is to code in a defensive style. This is a well known tactic that helps prevent bugs, especially the hard-to-track down kind. Defensive programming is defined as:<br/><br/>Designing with foresight to ensure a piece of software continues functioning correctly under unforeseen circumstances.<br/><br/>Of note here is that every single object in SQL Server belongs to a specific schema. Most often, that schema is simply the dbo schema, and one can quite easily design an entire database full of stored procedures, views, functions, etc and never even realize there is a concept of schemas, since everything will just, by default, be created in the dbo schema. One could do this, however I would not recommend it, for the following reasons:<br/><br/>It makes for hard to interpret code. Looking at the two SELECT statements below, there is more clarity around the one where the schema is explicitly specified.<br/><br/>SELECT name FROM databases;<br/>SELECT name FROM sys.databases;<br/><br/>Since I've specified sys.databases, you know instantly, and without question that results will come from the system view. Specifying the schema makes complex code far easier to reliably understand.<br/><br/>Schema resolution may not always work as you intend. If you have multiple schemas in the database, SQL Server needs to perform a search for objects when you don't specify the schema. When you specify the schema, SQL Server knows exactly where to look for the object.<br/><br/>Two developers, Melanie and Hannah, are working on code. Melanie has their default schema set to 'Melanie', Hannah has their default schema set to 'Hannah'. Melanie creates the table, x, inadvertently in the Melanie schema since they didn't specify dbo in the CREATE TABLE statement. Melanie tells Hannah to start using table x. Hannah then proceeds to use table x without specifying a schema, but since both developers have different default schemas assigned to their login, their new code cannot locate the object. This looks like a bug to Hannah, meanwhile when Melanie runs the same code, it works perfectly. If both developers specify the schema, they will never see this bug.<br/><br/>Your database has two schemas, warehouse and accounting. Both schemas have a table named Invoices. The warehouse.Invoice table contains details about invoices that need to be processed. The accounting.Invoices table contains all the columns pertinent to the actual invoice, such as billing details, amount payable, etc. Code written by a user who has neither warehouse nor accounting as their default schema, who doesn't specify the schema name, will return an object resolution error either at run-time or when the code is being saved in to the database. In the code below, I'm creating the two invoices tables, in separate schemas:<br/><br/>Execution Plans that would typically be shared among users with different default schemas will be cached separately if the T-SQL statement referenced in the Execution Plan doesn't have schema prefixes. So, for example, the following simple T-SQL statement would be cached multiple times for each user that has a different default schema:<br/><br/>SELECT UserName FROM Users;<br/><br/>For a complex database, with many varying T-SQL statements being executed, by many different users, this can result in significant plan-cache bloat, which can negatively impact query execution. Not to mention each user may get a significantly different plan depending on the complexity of the statements being executed, and whether parameter sniffing is in play.<br/><br/>In an environment where there are many schemas and many objects, specifying the schema name limits the work SQL Server must do when resolving object names to object IDs at compilation time. Specifying the schema can add up to a significant reduction of load for large, busy databases, with complex code.<br/><br/>Fully qualifying names of all objects will result in removing the need for SQL Server to execute code paths that are required to resolve names. We have observed contention points also on the SOS_CACHESTORE spinlock type encountered when not utilizing fully qualified names in calls to stored procedures. Failure to fully qualify these names results in the need for SQL Server to look up the default schema for the user, which results in a longer code path required to execute the SQL.<br/><br/>Some objects do not have a default schema. Take the example shown here by Maria Zakourdaev regarding DDL triggers. When you create a server-side trigger, that trigger has no concept of a default schema, and so will fail at run time, which can be particularly painful. Maria admits in the article that they don't usually specify schemas, unless the code demands it. I would submit that if they were in the habit of always specifying the schema, Maria would have not spent hours chasing down that bug.<br/><br/>In summary, I always specify the schema for every bit of code I write, simply because it takes almost no effort while writing the code, and it guarantees me certain bugs simply will never happen.<br/><br/>Specifying the schema is low cost and high impact, which I think we can all agree is A Good Thing™. | Database Administrators Stack Exchange este un site de întrebări și răspunsuri pentru profesioniștii din domeniul bazelor de date care doresc să-și îmbunătățească abilitățile de bază de date și să învețe de la alții din comunitate. Este nevoie doar de un minut pentru a vă înscrie.<br/><br/>Când aplicațiile codifică un nume de schemă, "dbo.TABLE", reduce capacitatea DBA de a migra datele după cum este necesar.... uh, fals. Puteți plasa întotdeauna vizualizări pe partea de sus a tabelelor cu diferite nume de scheme, așa că cred că întrebarea dvs. se bazează pe o eroare, care invalidează întrebarea în general. Nu cred că întrebarea merită un vot negativ, dar gândurile tale despre închiderea ei sunt, probabil, exacte.<br/>– John EisbrenerJun 24 '19 la 14:35<br/><br/>@JohnEisbrener - Sunt deschis la motive pentru a utiliza nume de scheme. Dacă DBA poate înlocui întotdeauna tabele cu vizualizări care rezolvă la alte scheme, atunci de ce au aplicațiile specifica dbo.TABLE mai degrabă decât doar TABLE. Dacă dba creează o vizualizare, TABLE ar rezolva la dbo.TABLE, care este o vizualizare la mrpv3.TABLE. Care este valoarea de a avea codul sursă specifică dbo.?<br/>– litJun 24 '19 la 14:43<br/><br/>@ScottHodgin - Da, am citit asta înainte de a posta. Și sunt de acord, că într-un mediu prost gestionat, mai multe scheme pot provoca probleme, Dar, specificându-le pune mai multe limite asupra modului în care un DBA poate gestiona baza de date. Elimină opțiunea de modificare a schemei implicite a contului și necesită utilizarea vizualizărilor. Există alte mecanisme pentru a gestiona acest lucru?<br/>– litJun 24 '19 la 14:54<br/><br/>Dacă înțelegeți că nu este o bună practică, o alternativă va fi să utilizați SYNONYM<br/>– Kin ShahJun 24 '19 la 17:30<br/><br/>@MaxVernon - Am citit postarea. Explică clar cum funcționează SQL Server. Opinia mea este încă că codificarea hardcoding a unui nume de schemă în sursă face codul mai puțin flexibil. Fără un nume de schemă, aplicația poate rula fără modificări prin setarea DBA a schemei implicite pentru utilizatorul de execuție. Și, este un lucru mai puțin în cazul în care eroarea poate fi introdusă.<br/>– litJun 24 '19 la 19:50<br/><br/>2 Răspunsuri<br/>2<br/><br/>Se pare că înțelegeți acest lucru, dar în caz că... nu trebuie să specificați întotdeauna schema, atâta timp cât schema este schema implicită a utilizatorului.<br/><br/>Deci, puteți gestiona acest lucru la nivelul de conectare al SQL Server. O conectare poate fi setată la implicit, să zicem, schema 'MySchema'. Pentru această conectare, tabelul mySchema.Orders ar fi implicit pentru acel utilizator, adresându-se pur și simplu comenzilor.<br/><br/>Acest lucru nu este folosit adesea, deoarece poate deveni confuz, dar este un mod complet funcțional de a face acest lucru. Dar rețineți: dacă nu aveți tabelul mySchema. Comenzile din baza dvs. de date, sistemul va căuta dbo. De asemenea, comenzile. Acest lucru este minunat dacă doriți unele tabele personalizate și unele în comun - rău dacă utilizatorii mySchema nu ar trebui să aibă acces la tabele dbo.<br/><br/>Răspunsul scurt aici este Nu, nu este nici "sigur", nici "expedent", și, probabil, nu mai flexibil pentru a omite numele schemei. De fapt, făcând acest lucru este una dintre modalitățile clasice de "împușcat în picior."<br/><br/>Una dintre principalele reguli de programare este codificarea într-un stil defensiv. Aceasta este o tactică bine cunoscută care ajută la prevenirea bug-urilor, în special a tipului greu de urmărit. Programarea defensivă este definită ca:<br/><br/>Proiectarea cu previziune pentru a se asigura că o bucată de software continuă să funcționeze corect în circumstanțe neprevăzute.<br/><br/>De remarcat aici este faptul că fiecare obiect în SQL Server aparține unei scheme specifice. Cel mai adesea, acea schemă este pur și simplu schema dbo, și se poate proiecta destul de ușor o întreagă bază de date plină de proceduri stocate, vizualizări, funcții, etc. și nici măcar nu-și dă seama că există un concept de scheme, deoarece totul va fi creat în mod implicit în schema dbo. S-ar putea face acest lucru, dar nu aș recomanda, din următoarele motive:<br/><br/>Uitându-ne la cele două declarații SELECT de mai jos, există mai multă claritate în jurul celei în care schema este specificată în mod explicit.<br/><br/>SELECȚIONAȚI numele din bazele de date;<br/>SELECȚIONAȚI numele DE LA sys.databases;<br/><br/>Din moment ce am specificat sys.databases, știi instantaneu și fără îndoială că rezultatele vor veni din vizualizarea sistemului. Specificarea schemei face codul complex mult mai ușor de înțeles în mod fiabil.<br/><br/>Dacă aveți mai multe scheme în baza de date, SQL Server trebuie să efectueze o căutare pentru obiecte atunci când nu specificați schema. Când specificați schema, SQL Server știe exact unde să caute obiectul.<br/><br/>Doi dezvoltatori, Melanie și Hannah, lucrează la cod. Melanie are schema implicită setată la 'Melanie', Hannah are schema implicită setată la 'Hannah'. Melanie creează tabelul, x, din greșeală în schema Melanie, deoarece nu au specificat dbo în instrucțiunea CREATE TABLE. Melanie îi spune Hannei să înceapă să folosească tabelul x. Hannah trece apoi la utilizarea tabelului x fără a specifica o schemă, dar din moment ce ambii dezvoltatori au scheme implicite diferite alocate login-ului lor, noul lor cod nu poate localiza obiectul. Acest lucru pare a fi un bug pentru Hannah, în timp ce atunci când Melanie rulează același cod, funcționează perfect. Dacă ambii dezvoltatori specifică schema, nu vor vedea niciodată acest bug.<br/><br/>Baza dvs. de date are două scheme, depozit și contabilitate. Ambele scheme au un tabel numit Facturi. Depozitul. Tabelul de facturi conține detalii despre facturile care trebuie procesate. Contabilitatea. Tabelul Facturi conține toate coloanele relevante pentru factura reală, cum ar fi detaliile de facturare, suma de plătit etc. Codul scris de un utilizator care nu are nici stocare, nici contabilitate ca schema implicită, care nu specifică numele schemei, va returna o eroare de rezoluție a obiectului fie în timpul rulării, fie atunci când codul este salvat în baza de date. În codul de mai jos, creez cele două tabele de facturi, în scheme separate:<br/><br/>Planurile de execuție care ar fi de obicei partajate între utilizatorii cu scheme implicite diferite vor fi stocate în cache separat dacă instrucțiunea T-SQL la care se face referire în planul de execuție nu are prefixe de schemă. Deci, de exemplu, următoarea instrucțiune simplă T-SQL ar fi memorată în cache de mai multe ori pentru fiecare utilizator care are o schemă implicită diferită:<br/><br/>SELECȚIONAȚI numele de utilizator de la utilizatori;<br/><br/>Pentru o bază de date complexă, cu mai multe instrucțiuni T-SQL diferite fiind executate, de mai mulți utilizatori diferiți, acest lucru poate duce la o umflare semnificativă a planului-cache, care poate avea un impact negativ asupra execuției interogării. Ca să nu mai vorbim că fiecare utilizator poate obține un plan semnificativ diferit în funcție de complexitatea instrucțiunilor care sunt executate și dacă parametrii de sniffing sunt în joc.<br/><br/>Într-un mediu în care există mai multe scheme și mai multe obiecte, specificarea numelui schemei limitează lucrul pe care trebuie să-l facă SQL Server atunci când se rezolvă numele obiectelor la ID-urile obiectelor la momentul compilării. Specificarea schemei se poate adăuga la o reducere semnificativă a încărcăturii pentru baze de date mari, ocupate, cu cod complex.<br/><br/>Denumirile complet calificate ale tuturor obiectelor vor duce la eliminarea necesității ca SQL Server să execute căi de cod care sunt necesare pentru a rezolva numele. S-au observat puncte de dispută și asupra tipului de spinlock SOS_CACHESTORE întâlnit atunci când nu se utilizează nume complet calificate în apelurile la procedurile stocate. Necalificarea completă a acestor nume duce la necesitatea ca SQL Server să caute schema implicită pentru utilizator, ceea ce duce la o cale de cod mai lungă necesară pentru a executa SQL.<br/><br/>Unele obiecte nu au o schemă implicită. Luați exemplul prezentat aici de Maria Zakourdaev cu privire la declanșatoarele DDL. Când creați un declanșator de partea serverului, declanșatorul nu are conceptul unei scheme implicite și, prin urmare, va eșua în timpul rulării, ceea ce poate fi deosebit de dureros. Maria admite în articol că de obicei nu specifică scheme, cu excepția cazului în care codul o cere. Aș sugera că dacă ar fi avut obiceiul de a specifica întotdeauna schema, Maria nu și-ar fi petrecut ore întregi urmărind acel bug.<br/><br/>În rezumat, eu specific întotdeauna schema pentru fiecare bucată de cod pe care o scriu, pur și simplu pentru că nu necesită aproape nici un efort în timp ce scriu codul și îmi garantează că anumite bug-uri pur și simplu nu se vor întâmpla niciodată.<br/><br/>Specificarea schemei este un cost redus și un impact ridicat, ceea ce cred că putem fi cu toții de acord este un lucru bun. |
